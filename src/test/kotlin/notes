1. VARIABLES:

- для объявления переменной используется ключевое слово val или var:
  val = аналог final в java, нельзя присвоить другое значение (присваиваем значение только один раз и не меняем его в программе)
  var = значение переменной может перезаписываться!

Всегда по возможности использовать val вместо var !!!

- сначала пишем имя переменной, затем через двоеточие ее тип:
   var name: String

- тип переменной можно не указывать, если инициализируем сразу переменную, он будет определен автоматически:
   var name = "Nick" (другой тип переменной не сможет использоваться - будет выдаваться ошибка)

- нет примитивных типов переменных (нет int, long, double), только ссылочные, т.е. являются какими-то классами (например String).
В котлине используются ссылочные аналоги примитивные типов, т.е те же типы только с большой буквы
(Int - аналог int, Long - аналог long, Double - аналог double)
  var age: Int

2. NULLABLE TYPES
(это переменные, значение которых может быть null)

- по умолчанию все переменные в Котлин не nullable, поэтому в отличие от java, не возникнет при компиляции ошибка NullPointerException

- переменная будет не nullable пока это явно не будет указано (для этого нужно дабовить знак вопроса в конце типа) -> Int?

Если тип переменной записан со знаком вопроса - значит можно присвоить ей значение null:
     private var name: String? = null

- если переменная объявлена как null, но мы хотим вызвать какое-то значение, то можно использовать два метода:

    1) НЕ БЕЗОПАСНЫЙ: в конце имени переменной пишем два восклиц.знака "!!" ( ИмяПеременной!!.метод() )
    - в результате такого вызова может быть получен NullPointerException.
          println(name!!.length)

    2) БЕЗОПАСНЫЙ: с вопрос.знаком "?" после имени ( ИмяПеременной?.метод() )
    - не выбросится Exception, в консоли появится значение "null":
          println(name?.length)

- чтобы использовать значение по умолчанию (вместо null) используется оператор элвис ( имя?: значение по умолчанию )
   Например, name1?.length?:0 - если длина имени null, то нужно выводить/брать в расчеты 0

Example: даны 3 переменные типа String, которые могут быть null. Найти длину каждого значения переменной и сложить их

fun main() {
        val name1: String? = "1234"
        val name2: String? = null
        val name3: String? = "0"
        val result: Int? = (name1?.length?:0)!! + (name2?.length?:0)!! + (name3?.length?:0)!!
        println(result)
}


3. In Kotlin два вида коллекций (List) -
   - неизменяемые =     val list: List<Int> = ArrayList()
                        list.add(5)
                        println(list[0])

   - изменяемые (можно добавлять данные) =     val list2: MutableList<Int> = mutableListOf()
                                               list2.add(5)
                                               println(list2[0])

4. Цикл из массивов записывается след.образом:
   val array = arrayOf(1, 2,3,4,5,6)
   for (i in array){
      println(i)
   }


   Инициализация массива данных для цикла: val array = arrayOfNulls<Int?>(101)    //чтобы избежать NullPointerException

    //Цикл, чтобы вывести до определенного значения
      for (i in 1..20) {
         println(i)
      }

   //Цикл, чтобы вывести значения по возрастанию до последнего значения массива:

      for (i in 0 until array.size) {
         array[i] = i
      }
      for (i in array) {
         println(i)
      }

   //Цикл, чтобы вывести значения по убывающей и все четные:

      for (j in 100 downTo 0 step 2) {
         println(j)
      }


5. Выражение Switch можно записать в Котлин так:

        val time = 4
        val whetherIsGood = true
        val state = when {
            time in 6..15 && whetherIsGood -> {"go to walk"}
            time in 16..23 && !whetherIsGood -> {"read book"}
            else -> {"go to bed"}
        }
       println(state)

6. Примеры функций:
vararg - это ключево слово для обозначения аргументов переменной длины

fun main() {
    println(max(4, 10))
    println(separate("con"))
    println(crop("con"))
    println(sum(1,5,4))


}

//1. вывод макс числа из двух
fun max(a: Int, b: Int): Int = if (a > b) a else b

//2. на входе есть строка, вывести первые 5ть символов слова.
fun separate(c: String): String = if (c.length >= 5) c.substring(0,5) else c
//второй вариант записи:
fun crop(c: String): String = c.substring(0, min(5, c.length))

//3. Сумма всех введенных значений
fun sum(vararg numbers: Int): Int {
    var result = 0
    for (num: Int in numbers) {
        result += num
    }
    return result
}

7. Дефолтные и именованные параметры

- В качесте параметра можно передавать значение по умолчанию. В этом случае его можно не указывать при вызове метода

fun printInfo(lastName: String = "", name: String = "", patronym: String = "") {
    if(lastName.isNotEmpty()) {
        println("Фамилия: $lastName")
    }
    if (name.isNotEmpty()) {
        println("Имя: $name")
    }
    if (patronym.isNotEmpty()) {
        println("отчество: $patronym")
    }
}

- при вызове метода можно явно указывать параметр, которому мы присваиваем значени, при этом порядок не важен

fun main() {
printInfo(name ="Ivan", lastName = "Ivanov")
}

8. Функциональное программирование (в основе всего лежат функции)

8.1 Лямбда-выражения (анонимные функции)

В Котлин переменным можно присваивать значения функций, т.е прямо указать, что переменная теперь является функцией.
Для этого создаем переменную и указываем ее тип. Если функция принимает какие-то параметры, то в круглых скобках указываем
тип параметра. Затем ставим стрелку и указываем возвращаемый тип, после чего пишем знак присвоить (=) и в фигурных скобках
пише функцию.
Пример:
val sum: (Int, Int) -> Int = {a, b -> a + b}
println(sum(5, 4))

Если функция ничего не возвращает, то пишем Unit (аналог void in Java) после стрелки
val name: (String) -> Unit = { println("Hello, $it!")}

Если функция принимает ТОЛЬКО ОДИН параметр, то компилятор может создать переменную нужного типа за нас.
Создастся переменная с именем it.
Исходная функция:
 val square: (Int)-> Int = {a * a}
    println(square(4))

Отредактированная функция:
    val square: (Int)-> Int = {it * it}
    println(square(4))

8.2. Метод filter

Метод filter используется для передачи одного параметра и возвращает всегда boolean
Example - выбрать только четные значения массива:
val listOfNumbers = mutableListOf<Int>()
    for(i in 0..99) {
        listOfNumbers.add(i)
    }
    val listOfEvenNumbers = listOfNumbers.filter({number: Int -> number % 2 == 0 })

В качестве параметра в filter передаем функцию, для этого внутри круглых скобок пишем фигурные.
В этом примере в filter сначала возьмется первый элемент массива 0 и проверит его на четность, и затем каждую последующий элемент.
В результате создатся новая коллекция только с четными числами.

Note:
1. Если какая-то функция принимает в качестве параметра лямбда-выражение и данный парамет является последней, то круглые скобки можно не ставить
val listOfEvenNumbers = listOfNumbers.filter({it % 2 == 0 })
в отредактированном виде:
val listOfEvenNumbers = listOfNumbers.filter{it % 2 == 0}

2. Создание коллекции чисел: val numbers = (0..100).toList()

8.3.Method MAP (может преобразовать коллекцию в любую другую)
Метод MAP будет вызывать переданную функцию у каждого элемента списка, поэтому передаваемый тип должен соответствовать типу коллекции (например, быть только Int).
Возвращаемый тип R означает, что он может быть абсолютно любого типа

val numbers = (0..100).toList()
    val doubleNumbers = numbers.map { number: Int -> number * 0.2 }  //type Int можно опустить
    for(i in doubleNumbers){
        println(i)
    }

Можем преобразовать коллекцию чисел в список сотрудников:
    val employees = numbers.map { "Employee №$it" }
    for (employee in employees)
       println(employee)

8.4. бесконечная последовательность
Ленивая инициализация в бесконечной последовательности - использование элемента только в тот момент, когда он используется где-то в коде.
    val array = generateSequence (0) {it + 2}
    val evenList = array.take(10)
    for(i in evenList)
        println(i)

Сгенерировать бесконечную последовательность можно не только числами, но и символами:
 val arrayLetters = generateSequence ('A') {it + 1}
    val letterList = arrayLetters.take(10)
    for(a in letterList)
        println(a)

Сгенерировать бесконечную последовательность рандомных чисел:
    val arrayRandom = generateSequence {
        (Math.random()*100).toInt()}
    val randomList = arrayRandom.take(10)
    for(a in randomList)
        println(a)

8.5. Zip function
С помощью данной функции можно объединить два массива в один.
Например, создадим два массива: один с телефонами пользователей, другой с именами. И объединить их в один массив:

    val names = mutableListOf<String>()
    val phones = mutableListOf<Long>()
    for(i in 0..100){
        names.add("Name $i")
        phones.add(79_000_000_000 + (Math.random() * 1_000_000_000).toLong())
    }
    val users = names.zip(phones)
    for (user in users){
        println("Name: ${user.first}, Phone number: ${user.second}")
    }

8.6.FlatMap
Разворачивает все коллекции (лист в листе) и получается одна коллекция из вложенных элементов
 val revenueByWeek = listOf(
            listOf(1, 2, 5, 7, 6),
            listOf(10, 20, 15, 7, 16),
            listOf(13, 12, 50, 17, 60),
            listOf(11, 25, 15, 70, 16)
    )
val total2 = revenueByWeek.flatten()
    val average2 = total2.average()
    println(average2)

8.7.Функция Extentions - расширение функции новыми методами



